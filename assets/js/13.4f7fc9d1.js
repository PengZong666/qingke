(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{365:function(t,r,a){"use strict";a.r(r);var s=a(14),i=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),r("h3",{attrs:{id:"请问arraylist-linkedlist-vector的异同-谈谈你的理解-arraylist底层是什么-扩容机制-vector和arraylist的最大区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#请问arraylist-linkedlist-vector的异同-谈谈你的理解-arraylist底层是什么-扩容机制-vector和arraylist的最大区别"}},[t._v("#")]),t._v(" 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别？")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("ArrayList和LinkedList的异同")]),t._v(" "),r("blockquote",[r("p",[t._v("二者都是线程不安全的，相对线程安全的Vector，执行效率高。")]),t._v(" "),r("p",[t._v("ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作以及add和remove，LinkedList比较占优势，因为ArrayList要移动数据。")])])]),t._v(" "),r("li",[r("p",[t._v("ArrayList和Vector的区别")]),t._v(" "),r("blockquote",[r("p",[t._v("Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下，大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。")])])])]),t._v(" "),r("h3",{attrs:{id:"负载因子值的大小-对hashmap有什么影响"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#负载因子值的大小-对hashmap有什么影响"}},[t._v("#")]),t._v(" 负载因子值的大小，对HashMap有什么影响")]),t._v(" "),r("blockquote",[r("ul",[r("li",[t._v("负载因子的大小决定了HashMap的数据密度。")]),t._v(" "),r("li",[t._v("负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降。")]),t._v(" "),r("li",[t._v("负载因子越小，就越容易触发扩容，数据密度也越小，意味着发射如果碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内存空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。")]),t._v(" "),r("li",[t._v("按照其它语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。")])])])])}),[],!1,null,null,null);r.default=i.exports}}]);