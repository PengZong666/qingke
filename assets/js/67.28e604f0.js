(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{418:function(e,n,a){"use strict";a.r(n);var t=a(14),s=Object(t.a)({},(function(){var e=this._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("blockquote",[e("p",[this._v("11、【初始化所有剩下的单实例bean】finishBeanFactoryInitialization(beanFactory);\n1、【初始化剩下的单实例bean】beanFactory.preInstantiateSingletons();\n1、获取容器中的所有bean，依次进行初始化和创建对象\n2、获取Bean的定义信息：RootBeanDefinition\n3、Bean不是抽象的、是单实例的、不是懒加载的\n1、判断是否是FactoryBean，是否是实现FactoryBean接口的Bean\n2、不是工厂Bean，利用getBean(beanName);创建对象\n1、getBean(beanName); IOC.getBean(beanName);\n2、doGetBean(name, null, null, false);\n3、getSingleton(beanName); 先获取缓存中保存的单实例Bean，如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n4、缓存中获取不到，开始Bean的创建对象流程\n5、【标记当前bean已经被创建了】markBeanAsCreated(beanName);\n6、【获取Bean的定义信息】getMergedLocalBeanDefinition(beanName);\n7、【获取当前Bean依赖的其它Bean，如果有按照getBean()把依赖的Bean先创建出来】mbd.getDependsOn();\n8、启动单实例Bean的创建流程\n1、createBean(beanName, mbd, args);\n2、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\nInstantiationAwareBeanPostProcessor提前执行\n先触发postProcessBeforeInstantiation\n如果有返回值，触发postProcessAfterInstantiation\n3、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象\n4、【创建Bean】Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n1、【创建Bean实例】instanceWrapper = createBeanInstance(beanName, mbd, args);\n利用工厂方法或者对象的构造器创建出Bean实例\n2、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);\n3、【对Bean的属性赋值】populateBean(beanName, mbd, instanceWrapper);\n1、拿到InstantiationAwareBeanPostProcessor后置处理器，执行postProcessAfterInstantiation\n2、拿到InstantiationAwareBeanPostProcessor后置处理器，执行postProcessPropertyValues\n====================赋值之前====================\n3、applyPropertyValues(beanName, mbd, bw, pvs); 应用Bean属性的值，为属性利用setter方法等进行赋值\n4、【Bean初始化】exposedObject = initializeBean(beanName, exposedObject, mbd);\n1、【执行Aware接口的方法】invokeAwareMethods(beanName, bean);\nBeanNameAware、BeanClassLoaderAware、BeanFactoryAware\n2、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\nbeanProcessor.postProcessBeforeInitialization(result, beanName);\n3、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);\n1、是否是InitializingBean接口的实现，执行接口规定的初始化\n2、是否自定义初始化方法\n4、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\nbeanProcessor.postProcessAfterInitialization(result, beanName);\n5、【注册Bean的销毁方法】registerDisposableBeanIfNecessary(beanName, bean, mbd);\n5、将创建的Bean添加到缓存中singletonObjects\nIOC容器就是这些Map，很多的Map里面保存了单实例Bean、环境信息...\n4、所有Bean都利用getBean创建完成以后\n检查所有Bean是否是SmartInitializingSingleton接口的，如果是，就执行smartSingleton.afterSingletonsInstantiated();")])])])}),[],!1,null,null,null);n.default=s.exports}}]);