(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{419:function(e,n,a){"use strict";a.r(n);var t=a(14),o=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("blockquote",[n("p",[e._v("Spring容器的refresh() 【创建刷新】\n1、prepareRefresh(); 刷新前的预处理\n1、initPropertySources(); 初始化一些属性设置，子类自定义个性化的属性设置方法\n2、getEnvironment().validateRequiredProperties(); 校验属性的合法等\n3、this.earlyApplicationEvents = new LinkedHashSet"),n("ApplicationEvent",[e._v("(); 保存容器中的一些早期的事件\n2、ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 获取BeanFactory\n1、refreshBeanFactory(); 刷新【创建】BeanFactory\n创建一个 this.beanFactory = new DefaultListableBeanFactory();\n设置id\n2、ConfigurableListableBeanFactory beanFactory = getBeanFactory();\nreturn this.beanFactory; 返回GenericApplicationContext刚才创建的BeanFactory\n3、return beanFactory; 将创建好的BeanFactory【DefaultListableBeanFactory】返回\n3、prepareBeanFactory(beanFactory); BeanFactory的预准备工作（对BeanFactory进行一些设置）\n1、设置BeanFactory的类加载器、支持表达式解析器......\n2、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】\n3、设置忽略的自动装配的接口【EnvironmentAware、EmbeddedValueResolverAware、......】\n4、注册可以解析的自动装配，我们能够在任何组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext\n5、添加BeanPostProcessor【ApplicationListenerDetector】\n6、添加编译时的AspectJ\n7、给BeanFactory中注册一些能用的组件\nenvironment【ConfigurableEnvironment】、\nsystemProperties【Map<String, Object>】、\nsystemEnvironment【Map<String, Object>】\n4、postProcessBeanFactory(beanFactory); BeanFactory准备工作完成后进行的后置处理工作\n1、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步设置")])],1),e._v(" "),n("p",[e._v("================================以上是BeanFactory的创建并预准备工作================================")]),e._v(" "),n("p",[e._v("5、invokeBeanFactoryPostProcessors(beanFactory); 执行BeanFactoryPostProcessor\nBeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的\n两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor\n1、先执行BeanDefinitionRegistryPostProcessor的方法：\n1、获取所有的BeanDefinitionRegistryPostProcessor\n2、先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor\npostProcessor.postProcessBeanDefinitionRegistry(registry);\n3、在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor\npostProcessor.postProcessBeanDefinitionRegistry(registry);\n4、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessor\npostProcessor.postProcessBeanDefinitionRegistry(registry);\n2、再执行BeanFactoryPostProcessor的方法：\n1、获取所有的BeanFactoryPostProcessor\n2、先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor\npostProcessor.postProcessBeanFactory(beanFactory);\n3、在执行实现了Ordered顺序接口的BeanFactoryPostProcessor\npostProcessor.postProcessBeanFactory(beanFactory);\n4、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor\npostProcessor.postProcessBeanFactory(beanFactory);\n6、registerBeanPostProcessors(beanFactory); 注册BeanPostProcessor（Bean的后置处理器）【intercept bean creation.】\n不同接口类型的BeanPostProcessor在Bean创建前后的执行时机是不一样的\nBeanPostProcessor、\nDestructionAwareBeanPostProcessor、\nInstantiationAwareBeanPostProcessor、\nSmartInstantiationAwareBeanPostProcessor、\nMergedBeanDefinitionPostProcessor\n1、获取所有的BeanPostProcessor，后置处理器都默认可以通过PriorityOrdered、Ordered接口来指定优先级\n2、先注册PriorityOrdered优先级接口的BeanPostProcessor\n把每一个BeanPostProcessor添加到BeanFactory中\nbeanFactory.addBeanPostProcessor(postProcessor);\n3、再注册Ordered接口的\n4、注册一些剩下的\n5、最终注册MergedBeanDefinitionPostProcessor\n6、beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); 注册一个ApplicationListenerDetector来在Bean创建完成后检查是否是ApplicationListener，\n如果是this.applicationContext.addApplicationListener((ApplicationListener<?>) bean);\n7、【初始化MessageSource组件（做国际化功能：消息绑定、消息解析）】initMessageSource();\n1、ConfigurableListableBeanFactory beanFactory = getBeanFactory(); 获取BeanFactory\n2、看容器中是否有id为messageSource的组件\n如果有，赋值给messageSource属性；如果没有，自己创建一个DelegatingMessageSource\nMessageSource：取出国际化配置文件中某个key的值，能按照区域信息获取\n3、把创建好的MessageSource注册到容器中，以后获取国际化配置文件的时候，可以自动注入MessageSource\nbeanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\nMessageSource.String getMessage(String code, Object[] args, String defaultMessage, Locale locale);\n8、【初始化事件派发器】initApplicationEventMulticaster();\n1、获取BeanFactory\n2、从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster\n3、如果上一步没有配置，创建一个SimpleApplicationEventMulticaster\n4、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其它组件直接自动注入\n9、【留给子容器的（子类）】onRefresh();\n1、子类重写这个方法，在容器刷新的时候，可以自定义逻辑\n10、【给容器中将所有项目中的ApplicationListener注册进来】registerListeners();\n1、从容器中拿到所有的ApplicationListener\n2、将每个监听器添加到事件派发器中\ngetApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n3、getApplicationEventMulticaster().multicastEvent(earlyEvent); 派发之前步骤产生的事件\n11、【初始化所有剩下的单实例bean】finishBeanFactoryInitialization(beanFactory);\n1、【初始化剩下的单实例bean】beanFactory.preInstantiateSingletons();\n1、获取容器中的所有bean，依次进行初始化和创建对象\n2、获取Bean的定义信息：RootBeanDefinition\n3、Bean不是抽象的、是单实例的、不是懒加载的\n1、判断是否是FactoryBean，是否是实现FactoryBean接口的Bean\n2、不是工厂Bean，利用getBean(beanName);创建对象\n1、getBean(beanName); IOC.getBean(beanName);\n2、doGetBean(name, null, null, false);\n3、getSingleton(beanName); 先获取缓存中保存的单实例Bean，如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n4、缓存中获取不到，开始Bean的创建对象流程\n5、【标记当前bean已经被创建了】markBeanAsCreated(beanName);\n6、【获取Bean的定义信息】getMergedLocalBeanDefinition(beanName);\n7、【获取当前Bean依赖的其它Bean，如果有按照getBean()把依赖的Bean先创建出来】mbd.getDependsOn();\n8、启动单实例Bean的创建流程\n1、createBean(beanName, mbd, args);\n2、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\nInstantiationAwareBeanPostProcessor提前执行\n先触发postProcessBeforeInstantiation\n如果有返回值，触发postProcessAfterInstantiation\n3、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象\n4、【创建Bean】Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n1、【创建Bean实例】instanceWrapper = createBeanInstance(beanName, mbd, args);\n利用工厂方法或者对象的构造器创建出Bean实例\n2、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);\n3、【对Bean的属性赋值】populateBean(beanName, mbd, instanceWrapper);\n1、拿到InstantiationAwareBeanPostProcessor后置处理器，执行postProcessAfterInstantiation\n2、拿到InstantiationAwareBeanPostProcessor后置处理器，执行postProcessPropertyValues\n====================赋值之前====================\n3、applyPropertyValues(beanName, mbd, bw, pvs); 应用Bean属性的值，为属性利用setter方法等进行赋值\n4、【Bean初始化】exposedObject = initializeBean(beanName, exposedObject, mbd);\n1、【执行Aware接口的方法】invokeAwareMethods(beanName, bean);\nBeanNameAware、BeanClassLoaderAware、BeanFactoryAware\n2、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\nbeanProcessor.postProcessBeforeInitialization(result, beanName);\n3、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);\n1、是否是InitializingBean接口的实现，执行接口规定的初始化\n2、是否自定义初始化方法\n4、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\nbeanProcessor.postProcessAfterInitialization(result, beanName);\n5、【注册Bean的销毁方法】registerDisposableBeanIfNecessary(beanName, bean, mbd);\n5、将创建的Bean添加到缓存中singletonObjects\nIOC容器就是这些Map，很多的Map里面保存了单实例Bean、环境信息...\n4、所有Bean都利用getBean创建完成以后\n检查所有Bean是否是SmartInitializingSingleton接口的，如果是，就执行smartSingleton.afterSingletonsInstantiated();\n12、【完成BeanFactory的初始化创建工作，IOC容器就创建完成】finishRefresh();\n1、【初始化和生命周期有关的后置处理器】initLifecycleProcessor();   LifecycleProcessor\n默认从容器中找是否有LifecycleProcessor的组件，如果没有new DefaultLifecycleProcessor();加入到容器中\n写一个LifecycleProcessor的实现类，可以在BeanFactory刷新完成以及关闭的时候做一些事情\nvoid onRefresh();   void onClose();\n2、【拿到前面定义的生命周期处理器（BeanFactory），回调onRefresh()】getLifecycleProcessor().onRefresh();\n3、【发布容器刷新完成事件】publishEvent(new ContextRefreshedEvent(this));\n4、【最后一步】LiveBeansView.registerApplicationContext(this);")]),e._v(" "),n("p",[e._v("===================================总结===================================\n1、Spring在容器启动的时候，先会保存所有注册进来的Bean的定义信息\n1、XML注册Bean："),n("bean",[e._v("\n2、注解注册Bean：@Service、@Component、@Bean、xxx\n2、Spring容器会在合适的时机创建这些Bean\n1、用到这个Bean的时候，利用getBean创建Bean，创建好以后保存在容器中\n2、统一创建剩下的Bean的时候：finishBeanFactoryInitialization(beanFactory);\n3、后置处理器\n每一个bean创建完成，都会使用各种后置处理器进行处理，来增强bean的功能\nAutowiredAnnotationBeanPostProcessor：处理自动注入\nAnnotationAwareAspectJAutoProxyCreator：来做AOP功能\nxxx...\n增强的功能注解\nAsyncAnnotationBeanPostProcessor\n....\n4、事件驱动模型\nApplicationListener：事件监听")])],1)])])}),[],!1,null,null,null);n.default=o.exports}}]);